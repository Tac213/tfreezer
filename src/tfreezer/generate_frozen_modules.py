# -*- coding: utf-8 -*-
# author: Tac
# contact: cookiezhx@163.com

"""
Script for generating frozen module headers
"""

import sys
import os
import re
import types
import typing
import enum
import importlib
from importlib import machinery, util
import modulefinder
import dataclasses
import subprocess
import shutil
import multiprocessing

if os.environ.get("DEBUG"):
    import debugpy

from tfreezer import paths, log, utils, config, freeze_module

# See: ${CPYTHON_SRC}/Python/frozen.c
OFFICIAL_FROZEN_MODULE_NAMES = (
    "_frozen_importlib",
    "_frozen_importlib_external",
    "zipimport",
    "abc",
    "codecs",
    "io",
    "_collections_abc",
    "_sitebuiltins",
    "genericpath",
    "ntpath",
    "posixpath",
    "os.path",
    "os",
    "site",
    "stat",
    "importlib.util",
    "importlib.machinery",
    "runpy",
    # alias
    "importlib._bootstrap",
    "importlib._bootstrap_external",
)

FROZEN_MODULES_HEADER_SRC = """\
// Generated by: tfreezer.generate_frozen_modules
#include "Python.h"
{frozen_headers}

static struct _frozen _PyImport_FrozenModules[] = {{
{module_infos}
    {{0, 0, 0}}  /* sentinel */
}};
"""


@dataclasses.dataclass
class ModuleInfo:
    """
    Data class of module info
    """

    module_name: str
    module: types.ModuleType
    is_package: bool
    origin: str


@dataclasses.dataclass
class ModuleAnalysisInfo:
    """
    Data class of module analysis info
    """

    entry_module_name: str  # A python module name or a signle python_file
    hidden_imports: list[str]  # hidden import module names
    excludes: list[str]  # exclude module names


class ModuleType(enum.IntFlag):
    """
    Module type enum
    """

    SOURCE_MODULE = enum.auto()
    BYTECODE_MODULE = enum.auto()
    EXTENSION_MODULE = enum.auto()


def is_frozen_module(module_name: str) -> bool:
    """
    Check whether the module is a frozen module in current environment
    Args:
        module_name: full name of the module
    Returns:
        bool
    """
    if module_name not in OFFICIAL_FROZEN_MODULE_NAMES:
        return False
    try:
        module = importlib.import_module(module_name)
    except ImportError:
        return False
    return module.__loader__ is machinery.FrozenImporter


def is_namespace_module(module_name: str) -> bool:
    """
    Check whether the module is a namespace module
    """
    try:
        module = importlib.import_module(module_name)
    except ImportError:
        return False
    return isinstance(module.__loader__, machinery.NamespaceLoader)


def get_list_arg(arg_str: str, arg_name: str = "") -> typing.List[str]:
    """
    Get command line list arg
    Args:
        arg_str: raw command line string
        arg_name: expected arg name
    Returns:
        list
    """
    argname, _, args = arg_str.partition("=")
    if arg_name and arg_name != argname:
        usage(f"Incorrect arg name: {argname}, expected: {arg_name}")
    list_args = re.split(r"\s?,\s?", args)
    while "" in list_args:
        list_args.remove("")
    return list_args


def get_python_bootstrap_module_names() -> typing.List[str]:
    """
    Get python bootstrap module names
    Returns:
        list
    """
    with subprocess.Popen(
        f'{sys.executable} -c "import sys; print(list(sys.modules.keys()))"', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE
    ) as p:
        p.wait()
        stdout, stderr = p.communicate()
        if p.returncode:
            usage(f"Could not get python bootstrap modules, {str(stderr, 'utf-8')}")
        bootstrap_module_names: typing.List[str] = eval(stdout)  # pylint: disable=eval-used
    if "__main__" in bootstrap_module_names:
        bootstrap_module_names.remove("__main__")
    for official_frozen_module_name in OFFICIAL_FROZEN_MODULE_NAMES:
        if is_frozen_module(official_frozen_module_name) and official_frozen_module_name in bootstrap_module_names:
            bootstrap_module_names.remove(official_frozen_module_name)
    for name in bootstrap_module_names[:]:
        if is_namespace_module(name):
            bootstrap_module_names.remove(name)
    editable_finder_name = None
    for name in bootstrap_module_names:
        if name.startswith("__editable__"):
            editable_finder_name = name
            break
    if editable_finder_name is not None:
        bootstrap_module_names.remove(editable_finder_name)
    return bootstrap_module_names


def clear_frozen_module_dir() -> None:
    """
    Clear frozen module dir
    Returns:
        None
    """
    if os.path.isdir(paths.FROZEN_MODULE_DIR):
        shutil.rmtree(paths.FROZEN_MODULE_DIR)
    os.makedirs(paths.FROZEN_MODULE_DIR)


def is_package(module: types.ModuleType) -> bool:
    """
    Return True if the module is a package.
    Args:
        module
    Returns:
        bool
    """
    module_path = module.__spec__.origin
    file_name = os.path.split(module_path)[1]
    return any(file_name == "__init__" + suffix for suffix in machinery.SOURCE_SUFFIXES)


def file_is_package(module_path: str) -> bool:
    """
    Return True if the file is a package.
    Args:
        module
    Returns:
        bool
    """
    file_name = os.path.split(module_path)[1]
    return any(file_name == "__init__" + suffix for suffix in machinery.SOURCE_SUFFIXES)


def create_module(fullname: str) -> types.ModuleType:
    """
    Create a module object but do not exec it
    Only external modules (.py .pyc .pyd .pyw) will be found
    Args:
        fullname: module fullname
    Returns:
        module object
    """
    if fullname in sys.modules:
        return sys.modules[fullname]
    path_list = None
    parent_module_name = fullname.rpartition(".")[0]
    if parent_module_name:
        parent_module = create_module(parent_module_name)
        path_list = parent_module.__path__
    spec = None
    for finder in sys.meta_path:
        if finder in (machinery.BuiltinImporter, machinery.FrozenImporter):
            continue
        spec = finder.find_spec(fullname, path_list)
        if spec:
            break
    if spec is None:
        raise ModuleNotFoundError(f"No module named {fullname}", name=fullname)
    module = util.module_from_spec(spec)
    return module


def get_module_info(module_name: str, is_entry_module: bool = False) -> ModuleInfo:
    """
    Get module info by module name
    Args:
        module_name: A python module name or a single python_file
        is_entry_module: whether the given module is an entry module
    Returns:
        ModuleInfo
    """
    if module_name.endswith(tuple(machinery.SOURCE_SUFFIXES)):
        source_module_path = os.path.abspath(module_name)
        fullname = "__main__"
        loader = machinery.SourceFileLoader(fullname, source_module_path)
        spec = util.spec_from_file_location(fullname, source_module_path, loader=loader)
        module = util.module_from_spec(spec)
        module_info = ModuleInfo(fullname, module, is_package(module), source_module_path)
    else:
        try:
            module = create_module(module_name)
        except ModuleNotFoundError as e:
            usage(e.msg)
        if is_package(module) and is_entry_module:
            module_name = f"{module_name}.__main__"
            try:
                module = create_module(module_name)
            except ModuleNotFoundError as e:
                usage(e.msg)
            source_module_path = module.__spec__.origin
        else:
            source_module_path = module.__spec__.origin
        module_info = ModuleInfo(module_name, module, is_package(module), source_module_path)
    return module_info


def get_module_varname(name: str, prefix: str) -> str:
    """
    Get module varname in header file
    Copy from ${CPYTHON_SRC}/Programs/_freeze_module.py
    Args:
        name: module name
        prefix: prefix of the varname
    Returns:
        varname
    """
    if "importlib_metadata" in name:
        # importlib_metadata is a site-package on PyPI: https://pypi.org/project/importlib-metadata/
        # The variable name of it conflicts with importlib.metadata, which is an official package
        name = name.replace("importlib_metadata", "importlib_metadata_pypi")
    return f"{prefix}{name.replace('.', '_')}"


def analyze_module(analysis_info: ModuleAnalysisInfo, module_type: ModuleType) -> dict[str, modulefinder.Module]:
    """
    Get all [module_type] of modules used by [analysis_info]
    Returns:
        All module infos
    """
    hidden_imports = analysis_info.hidden_imports[:]
    excludes = analysis_info.excludes[:]
    is_win = sys.platform.startswith("win")
    if is_win:
        # copy from ${CPYTHON_SRC}/Tools/freeze/freeze.py
        excludes += [
            "dos",
            "dospath",
            "mac",
            "macfs",
            "MACFS",
            "posix",
            "tty",
        ]
    bootstrap_module_names = get_python_bootstrap_module_names()
    # modules that are imported by the Python runtime
    # copy from ${CPYTHON_SRC}/Tools/freeze/freeze.py
    bootstrap_module_names += ["site", "warnings", "encodings.utf_8", "encodings.latin_1"]
    hidden_imports += bootstrap_module_names
    if "os.path" in hidden_imports:
        hidden_imports.remove("os.path")  # remove alias module

    if "pathlib" not in hidden_imports:
        # pathlib is used by bootstrap module: tf_importer
        hidden_imports.append("pathlib")

    module_info = get_module_info(analysis_info.entry_module_name, is_entry_module=True)
    additional_path = None
    path = sys.path[:]
    for entry in path:
        if not entry.startswith("__editable__"):
            continue
        module_name, _, _ = entry.rpartition(".")
        module_name = module_name.replace(".", "_").replace("-", "_")
        editable_finder_module = importlib.import_module(module_name)
        additional_path = editable_finder_module.MAPPING.get(analysis_info.entry_module_name)
        additional_path = os.path.dirname(additional_path)
    if additional_path is not None:
        path.append(additional_path)
    finder = modulefinder.ModuleFinder(path=path, excludes=excludes)

    # Add tfreezer bootstrap modules
    tf_bootstrap = modulefinder.Module("tf_bootstrap", os.path.join(os.path.dirname(__file__), "bootstrap", "tf_bootstrap.py"))
    finder.modules[tf_bootstrap.__name__] = tf_bootstrap
    tf_importer = modulefinder.Module("tf_importer", os.path.join(os.path.dirname(__file__), "bootstrap", "tf_importer.py"))
    finder.modules[tf_importer.__name__] = tf_importer
    tf_multiprocessing = modulefinder.Module(
        "tf_multiprocessing", os.path.join(os.path.dirname(__file__), "bootstrap", "tf_multiprocessing.py")
    )
    finder.modules[tf_multiprocessing.__name__] = tf_multiprocessing
    tf_pywin32 = modulefinder.Module("tf_pywin32", os.path.join(os.path.dirname(__file__), "bootstrap", "tf_pywin32.py"))
    finder.modules[tf_pywin32.__name__] = tf_pywin32

    for hidden_import_name in hidden_imports:
        if hidden_import_name.startswith(("win32comext", "win32com")):
            real_module = importlib.import_module(hidden_import_name)
            _, _, child_mod_name = hidden_import_name.partition(".")
            hidden_import_name = f"win32com.{child_mod_name}"
            finder.modules[hidden_import_name] = modulefinder.Module(
                hidden_import_name, real_module.__file__, getattr(real_module, "__path__", None)
            )
            continue
        if hidden_import_name.startswith("pywin32"):
            continue
        finder.import_hook(hidden_import_name)

    finder.run_script(module_info.origin)
    if os.environ.get("DEBUG"):
        finder.report()
    modules = {}
    for module_name, module in finder.modules.items():
        if module_name in sys.builtin_module_names:
            continue
        if module.__file__.endswith(tuple(machinery.SOURCE_SUFFIXES)) and module_type & ModuleType.SOURCE_MODULE:
            modules[module_name] = module
        if module.__file__.endswith(tuple(machinery.BYTECODE_SUFFIXES)) and module_type & ModuleType.BYTECODE_MODULE:
            modules[module_name] = module
        if module.__file__.endswith(tuple(machinery.EXTENSION_SUFFIXES)) and module_type & ModuleType.EXTENSION_MODULE:
            modules[module_name] = module
    return modules


def get_frozen_module_names(
    analysis_info: ModuleAnalysisInfo, *, info: typing.Optional[dict[str, modulefinder.Module]] = None
) -> list[str]:
    """
    Get all frozen module names
    Returns:
        All frozen module names
    """
    modules = analyze_module(analysis_info, ModuleType.SOURCE_MODULE)
    module_names = sorted(modules.keys())
    frozen_module_names = []
    for module_name in module_names:
        if is_frozen_module(module_name):
            continue
        frozen_module_names.append(module_name)
    if info is not None:
        for module_name, module in modules.items():
            info[module_name] = module
    return frozen_module_names


def _dump_frozen_module_info(module_names: list[str], module_info: dict[str, modulefinder.Module], headers: list[str]) -> None:
    """
    Dump frozen module info to build directory
    """
    info_file = os.path.join(paths.BUILD_DIR, "frozen_module_cache")
    info_file_contents = ["FROZEN_MODULES = {"]
    for module_name in module_names:
        file_path = "Unknown file"
        module = module_info.get(module_name)
        if module:
            file_path = module.__file__
        info_file_contents.append(f'    "{module_name}": r"{file_path}",')
    info_file_contents.append("}")
    info_file_contents.append("")  # extra empty line to make the file prettier
    with open(info_file, "w", encoding="utf-8") as fp:
        fp.write("\n".join(info_file_contents))
    cmake_info_file = os.path.join(paths.BUILD_DIR, "frozen_headers")
    with open(cmake_info_file, "w", encoding="utf-8") as fp:
        fp.write(";".join(headers))


def _load_frozen_module_info() -> dict[str, str]:
    """
    Load frozen module names and paths
    """
    info_file = os.path.join(paths.BUILD_DIR, "frozen_module_cache")
    if not os.path.isfile(info_file):
        usage(f"Failed to load frozen module info. No such file: '{info_file}'")
    fullname = "tfreezer.frozen_module_cache"
    module = utils.load_signle_module(fullname, info_file)
    assert hasattr(module, "FROZEN_MODULES")
    return module.FROZEN_MODULES


def print_frozen_header_file_names(entry_module_name: str, hidden_imports_arg: str, excludes_arg: str) -> None:
    """
    Print all frozen header file names for cmake
    Args:
        entry_module: A python module name or a single python_file
        hidden_imports_arg: hidden import modules, e.g. --hidden-imports=xx,yy,aa.bb
        excludes_arg: excludes modules, e.g. --excludes=test,unittest
    Returns:
        None
    """
    if os.path.isfile(entry_module_name) and not entry_module_name.endswith(".py"):
        with open(entry_module_name, "r", encoding="utf-8") as fp:
            entry_module_name = fp.read().strip()
    file_name = hidden_imports_arg.rpartition("=")[-1]
    if os.path.isfile(file_name):
        with open(file_name, "r", encoding="utf-8") as fp:
            hidden_imports_arg = f"--hidden-imports={fp.read().strip()}"
    file_name = excludes_arg.rpartition("=")[-1]
    if os.path.isfile(file_name):
        with open(file_name, "r", encoding="utf-8") as fp:
            excludes_arg = f"--excludes={fp.read().strip()}"
    hidden_imports = get_list_arg(hidden_imports_arg, "--hidden-imports")
    excludes = get_list_arg(excludes_arg, "--excludes")
    analysis_info = ModuleAnalysisInfo(entry_module_name, hidden_imports, excludes)
    module_info = {}
    module_names = get_frozen_module_names(analysis_info, info=module_info)
    headers = [paths.FROZEN_MODULES_HEADER.replace("\\", "/")]
    for module_name in module_names:
        header = os.path.join(paths.FROZEN_MODULE_DIR, f"{module_name}.h")
        header = header.replace("\\", "/")
        headers.append(header)
    _dump_frozen_module_info(module_names, module_info, headers)


def freeze(module_name: str, module_file: str, header_path: str) -> None:
    """
    Freeze module
    Entry function in multiprocessing
    """
    log.logger.info("Generating header: '%s'", header_path)
    text = freeze_module.read_text(module_file)
    marshalled = freeze_module.compile_and_marshal(module_name, text)
    freeze_module.write_frozen(header_path, module_file, module_name, marshalled)


def make_freeze(entry_module_name: str) -> None:
    """
    Generate all frozen headers for the entry_module_name
    Args:
        hidden_imports_arg: hidden import modules, e.g. --hidden-imports=xx,yy,aa.bb
        excludes_arg: excludes modules, e.g. --excludes=test,unittest
    Returns:
        None
    """
    if sys.version_info >= (3, 11):
        os.environ["PYDEVD_DISABLE_FILE_VALIDATION"] = "1"
    clear_frozen_module_dir()
    if os.path.isfile(entry_module_name):
        with open(entry_module_name, "r", encoding="utf-8") as fp:
            entry_module_name = fp.read().strip()
    modules = _load_frozen_module_info()
    headers = []
    frozen_structs = []
    with multiprocessing.Pool(processes=multiprocessing.cpu_count()) as pool:
        for module_name, module_file in modules.items():
            if module_name == "__main__":
                module_info = get_module_info(entry_module_name, is_entry_module=True)
                module_file = module_info.origin
            elif not os.path.isfile(module_file):
                module_info = get_module_info(module_name)
                module_file = module_info.origin
            header_name = f"{module_name}.h"
            header_path = os.path.join(paths.FROZEN_MODULE_DIR, header_name)
            pool.apply_async(freeze, args=(module_name, module_file, header_path))
            headers.append(f'#include "{header_name}"')
            varname = get_module_varname(module_name, "_Py_M__")
            is_package_literal = "true" if file_is_package(module_file) else "false"
            frozen_struct_literal = f'    {{"{module_name}", {varname}, (int)sizeof({varname}), {is_package_literal}}},'
            frozen_structs.append(frozen_struct_literal)
        pool.close()
        pool.join()
    headers_literal = "\n".join(headers)
    frozen_structs_literal = "\n".join(frozen_structs)
    frozen_modules_header_src = FROZEN_MODULES_HEADER_SRC.format(frozen_headers=headers_literal, module_infos=frozen_structs_literal)
    with open(paths.FROZEN_MODULES_HEADER, "w", encoding="utf-8") as fp:
        fp.write(frozen_modules_header_src)


def main() -> None:
    """
    Entry point
    Returns:
        None
    """
    if os.environ.get("DEBUG"):
        debugpy.listen(("localhost", 36938))
        log.logger.info("Waiting for VSCode to attach... ip: localhost:36938")
        debugpy.wait_for_client()

    options = []

    # option, function, error, description
    options.append(
        (
            "--get-frozen-header-file-names",
            print_frozen_header_file_names,
            "Unable to get frozen header file names.",
            "Print all frozen header file names for cmake.",
        )
    )
    options.append(
        (
            "--make-freeze",
            make_freeze,
            "Unable to locate the Python library for linking.",
            "Generate all frozen headers.",
        )
    )

    option = sys.argv[1]
    build_dir = sys.argv[2]
    paths.load_paths(build_dir)
    config.load_sys_path()
    for argument, handler, _, _ in options:
        if option != argument:
            continue
        handler(*sys.argv[3:])


def usage(msg: str) -> None:
    """
    Print message and exit
    Args:
        msg: message to show
    Returns:
        None
    """
    log.logger.error("Error: %s", msg)
    sys.exit(1)


if __name__ == "__main__":
    main()
